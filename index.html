<!DOCTYPE html>
<html lang="en">
<head>
  <title>The Standard</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons|Lobster|Lato:400,700|Roboto:300,300i,400,400i,700,700i" rel="stylesheet" />
  <meta name="viewport" content="width=device-width, user-scalable=no" />
  <script src="elements/device.js"></script>
  <script src="elements/scene.js"></script>
  <script src="elements/page.js"></script>
  <script src="elements/lines.js"></script>
  <script src="elements/feature.js"></script>
  <script src="elements/scroll.js"></script>
  <script src="elements/ui/header.js"></script>
  <script src="elements/ui/loader.js"></script>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>

<tsui-header id="header">
  <tsui-loader id="loader" scripts="/scripts.json"></tsui-loader>
</tsui-header>

<ts-scene id="scene" disabled>
  <ts-device device="tablet">
    <ts-page>
    </ts-page>
  </ts-device>
</ts-scene>

<script>
'use strict';
(function() {
  // IIFE for header script chooser bind to hash
  window.addEventListener('hashchange', ev => header.script = window.location.hash.substr(1));
  if (window.location.hash) {
    window.dispatchEvent(new CustomEvent('hashchange'));
  }
  const mo = new MutationObserver(_ => {
    window.history.replaceState(null, null, header.script ? `#${header.script}` : '/');
    document.body.dispatchEvent(new CustomEvent('script', {detail: header.script}));
  });
  mo.observe(header, {attributes: true, attributeFilter: ['script']});
}());

(function() {
// IIFE for old script player

const device = document.querySelector('ts-device');
const sceneInterval = 2500;
let scripts = {};

document.body.addEventListener('scripts', ev => {
  scripts = ev.detail;
  playVideo(header.script);
});
document.body.addEventListener('script', ev => playVideo(header.script));

header.addEventListener('step', ev => device.stepDevice());

const playVideo = (function() {
  const scene = document.querySelector('ts-scene');
  const device = scene.querySelector('ts-device');
  const page = device.querySelector('ts-page');

  function reset() {
    page.class = '';
    scene.scene = null;
    device.overflow = false;
  }

  let interval;
  return function(id) {
    console.info('got id', id);
    window.clearTimeout(interval);

    if (!id) {
      page.html = '';
      page.css = '';
      return reset();
    }

    const s = scripts[id];
    if (!s) {
      throw new Error('no script for: ' + id);
    }

    const result = {};

    const fetchHTML = window.fetch(`scripts/${id}.html`)
        .then(out => out.text())
        .then(v => { result.html = v; });

    const fetchCSS = window.fetch(`scripts/${id}.css`)
        .then(out => out.text())
        .then(v => { result.css = v; });

    Promise.all([fetchHTML, fetchCSS]).then(_ => {
      page.html = result.html;
      page.css = result.css;
    }).then(_ => {
      let i = -1;
      interval = window.setTimeout(function draw() {
        let nextDelay = sceneInterval;

        switch (i) {
        case -1:
          console.info(id, 'start frame');
          i = 0;
          reset();
          scene.removeAttribute('disabled');
          break;
        case s.frames.length:
          console.info(id, 'last frame');
          i = -1;
          scene.setAttribute('disabled', '');
          break;
        default:
          console.info(id, 'frame', i);
          const frame = s.frames[i];
          if ('class' in frame) { page.class = frame.class; }
          if ('scene' in frame) { scene.scene = frame.scene; }
          if ('overflow' in frame) { device.overflow = frame.overflow; }
          if ('delay' in frame) { nextDelay = Math.max(frame.delay, nextDelay); }

          if ('value' in frame) {
            const el = page.q(frame.value.q);
            el.value = frame.value.value;
          }

          if ('attr' in frame) {
            const attr = frame.attr;
            const el = page.q(attr.q);
            if (attr.value !== undefined) {
              el.setAttribute(attr.name, attr.value);
            } else {
              el.removeAttribute(attr.name);
            }
          }

          if ('keyboard' in frame) {
            const k = frame.keyboard;
            const el = page.q(k.q);
            let remaining = k.value || '';
            el.focus();
            let first = true;

            const seg = (nextDelay / remaining.length) * 0.75;
            const interval = window.setInterval(() => {
              if (first) {
                el.value = '';
                first = false;
                return;
              }
              if (!remaining.length) {
                window.clearInterval(interval);
                return;
              }
              let i = 0;
              while (remaining[i] === ' ') {
                ++i;
              }
              el.value = el.value + remaining.substr(0, i + 1);
              el.focus();
              remaining = remaining.substr(i + 1);
            }, seg);
          }

          if ('click' in frame) {
            const el = page.q(frame.click);
            el.focus();
            window.setTimeout(() => {
              el.click();
            }, nextDelay * 0.25);
            window.setTimeout(() => {
              (document.activeElement || el).blur();
            }, nextDelay * 0.75);
          }

          if ('scroll' in frame) {
            const el = page.q(frame.scroll.q);

            const startAt = el.scrollTop;
            const scrollTo = frame.scroll.to;

            const start = performance.now();
            const update = whenever => {
              const delta = performance.now() - start;

              let ratio = (delta / nextDelay);
              ratio = Math.max(0, ratio);
              ratio = Math.min(1, ratio);

              el.scrollTop = (scrollTo - startAt) * ratio + startAt;

              if (ratio < 1) {
                window.requestAnimationFrame(update);
              }
            };
            window.requestAnimationFrame(update);

          }

          ++i;
          break;
        }

        interval = window.setTimeout(draw, nextDelay);
      }, sceneInterval);
    });
  };
}());

}());

</script>

</body>
</html>